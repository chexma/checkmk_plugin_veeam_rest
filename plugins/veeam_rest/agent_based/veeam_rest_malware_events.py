#!/usr/bin/env python3
"""
Check plugin for Veeam Malware Detection Events.

This check monitors malware events from Veeam's malware detection system,
showing which machines have been flagged and whether events have been
confirmed as false positives.

Also displays malwareStatus from backup restore points when available.
"""

import json
from collections.abc import Mapping
from datetime import datetime, timezone
from typing import Any

from cmk.agent_based.v2 import (
    AgentSection,
    CheckPlugin,
    CheckResult,
    DiscoveryResult,
    Metric,
    Result,
    Service,
    State,
    StringTable,
    render,
)


# =============================================================================
# SECTION PARSING
# =============================================================================

# Section: machine_name -> dict with events and optional backup status
# New format: {"machineName": str, "events": list, "malwareStatus": str|None, ...}
# Old format (list): Converted to new format during parsing
Section = dict[str, dict[str, Any]]


def parse_veeam_rest_malware_events(string_table: StringTable) -> Section | None:
    """Parse malware events data.

    Supports two formats:
    1. New combined format: dict[machine_name -> {events, malwareStatus, ...}]
    2. Old format: list of events (grouped by machine.name)
    """
    if not string_table:
        return None

    try:
        json_str = "".join(line[0] for line in string_table)
        data = json.loads(json_str)

        if not data:
            return None

        # Detect format: dict = new combined format, list = old event list
        if isinstance(data, dict):
            # New combined format - already keyed by machine name
            # Check if it's the expected structure
            first_value = next(iter(data.values()), None)
            if isinstance(first_value, dict) and "events" in first_value:
                return data
            # Single machine piggyback format
            if "machineName" in data and "events" in data:
                machine_name = data.get("machineName", "Unknown")
                return {machine_name: data}

        # Old format: list of events - group by machine name
        if isinstance(data, list):
            result: Section = {}
            for event in data:
                machine = event.get("machine", {})
                machine_name = machine.get("name", "Unknown")
                if machine_name not in result:
                    result[machine_name] = {
                        "machineName": machine_name,
                        "events": [],
                        "malwareStatus": None,
                        "restorePointsCount": 0,
                        "lastBackup": None,
                    }
                result[machine_name]["events"].append(event)
            return result if result else None

        return None
    except (json.JSONDecodeError, IndexError):
        return None


agent_section_veeam_rest_malware_events = AgentSection(
    name="veeam_rest_malware_events",
    parse_function=parse_veeam_rest_malware_events,
)


# =============================================================================
# DISCOVERY
# =============================================================================

def discover_veeam_rest_malware_events(section: Section) -> DiscoveryResult:
    """Discover one service per machine with malware events."""
    for machine_name in section:
        yield Service(item=machine_name)


# =============================================================================
# CHECK FUNCTION
# =============================================================================

# Severity to state mapping for events
SEVERITY_STATE = {
    "Infected": State.CRIT,
    "Suspicious": State.WARN,
    "Informative": State.OK,
    "Clean": State.OK,
}

# Event type display names
EVENT_TYPE_DISPLAY = {
    "DeletedUsefulFiles": "Deleted useful files",
    "RansomwareNotes": "Ransomware notes",
    "MalwareExtensions": "Malware extensions",
    "YaraRuleMatch": "YARA rule match",
    "AntivirusMatch": "Antivirus match",
    "Unknown": "Unknown",
}

# Source display names
SOURCE_DISPLAY = {
    "Manual": "Manual",
    "InternalVeeamDetector": "Veeam Detector",
    "External": "External",
    "MarkAsCleanEvent": "Marked Clean",
}

# State string to State object mapping
STATE_MAP = {
    "ok": State.OK,
    "warn": State.WARN,
    "crit": State.CRIT,
}


def check_veeam_rest_malware_events(
    item: str,
    params: Mapping[str, Any],
    section: Section,
) -> CheckResult:
    """Check malware events for a specific machine."""
    if item not in section:
        yield Result(state=State.OK, summary="No malware events")
        return

    data = section[item]
    events = data.get("events", [])

    # Get malwareStatus from backup restore point (if available)
    malware_status = data.get("malwareStatus")
    restore_points_count = data.get("restorePointsCount", 0)

    # Process malwareStatus with configurable states
    if malware_status:
        malware_states = params.get("malware_status_states", {})

        # Default state mapping
        default_mapping = {
            "Clean": State.OK,
            "Infected": State.CRIT,
            "Suspicious": State.WARN,
            "NotScanned": State.WARN,
        }

        # Override with configured parameters
        for status, state_str in malware_states.items():
            if state_str in STATE_MAP:
                default_mapping[status] = STATE_MAP[state_str]

        status_state = default_mapping.get(malware_status, State.OK)

        if status_state == State.CRIT:
            yield Result(state=status_state, summary=f"Backup scan: {malware_status}")
        elif status_state == State.WARN:
            yield Result(state=status_state, summary=f"Backup scan: {malware_status}")
        else:
            yield Result(state=State.OK, summary=f"Backup scan: {malware_status}")

    # Process events
    if not events:
        if not malware_status:
            yield Result(state=State.OK, summary="No malware events")
        return

    # Count events by state and severity
    total_events = len(events)
    active_events = [e for e in events if e.get("state") != "FalsePositive"]
    false_positives = [e for e in events if e.get("state") == "FalsePositive"]

    # Determine worst severity among active events
    worst_state = State.OK
    worst_severity = "Clean"
    for event in active_events:
        severity = event.get("severity", "Clean")
        event_state = SEVERITY_STATE.get(severity, State.OK)
        if event_state.value > worst_state.value:
            worst_state = event_state
            worst_severity = severity

    # Build events summary
    if not active_events:
        events_summary = f"All {total_events} event(s) confirmed as false positive"
        worst_state = State.OK
    else:
        events_summary = f"{len(active_events)} active event(s)"
        if worst_severity != "Clean":
            events_summary += f", worst: {worst_severity}"
        if false_positives:
            events_summary += f", {len(false_positives)} confirmed clean"

    yield Result(state=worst_state, summary=events_summary)

    # Metrics
    yield Metric("veeam_rest_malware_events_total", total_events)
    yield Metric("veeam_rest_malware_events_active", len(active_events))
    yield Metric("veeam_rest_malware_events_false_positive", len(false_positives))

    # Additional info from backup data
    if restore_points_count:
        yield Result(state=State.OK, notice=f"Restore points: {restore_points_count}")

    last_backup = data.get("lastBackup")
    if last_backup:
        yield Result(state=State.OK, notice=f"Last backup: {last_backup}")

    # Details for each active event
    for event in active_events:
        event_type = event.get("type", "Unknown")
        type_display = EVENT_TYPE_DISPLAY.get(event_type, event_type)
        severity = event.get("severity", "Unknown")
        source = event.get("source", "Unknown")
        source_display = SOURCE_DISPLAY.get(source, source)
        details = event.get("details", "")
        detection_time = event.get("detectionTimeUtc", "")

        # Parse detection time for age calculation
        age_str = ""
        if detection_time:
            try:
                dt = datetime.fromisoformat(detection_time.replace("Z", "+00:00"))
                age_seconds = int((datetime.now(timezone.utc) - dt).total_seconds())
                age_str = f", {render.timespan(age_seconds)} ago"
            except (ValueError, TypeError):
                pass

        event_info = f"{type_display} ({severity}) - Source: {source_display}{age_str}"
        if details:
            event_info += f" - {details[:100]}"

        event_state = SEVERITY_STATE.get(severity, State.OK)
        yield Result(state=event_state, notice=event_info)

    # Details for false positives (as notice only)
    for event in false_positives:
        event_type = event.get("type", "Unknown")
        type_display = EVENT_TYPE_DISPLAY.get(event_type, event_type)
        severity = event.get("severity", "Unknown")

        yield Result(
            state=State.OK,
            notice=f"[Confirmed Clean] {type_display} (was: {severity})"
        )


check_plugin_veeam_rest_malware_events = CheckPlugin(
    name="veeam_rest_malware_events",
    service_name="Veeam Malware %s",
    discovery_function=discover_veeam_rest_malware_events,
    check_function=check_veeam_rest_malware_events,
    check_default_parameters={
        "malware_status_states": {
            "Clean": "ok",
            "Infected": "crit",
            "Suspicious": "warn",
            "NotScanned": "warn",
        }
    },
    check_ruleset_name="veeam_rest_malware_events",
)
